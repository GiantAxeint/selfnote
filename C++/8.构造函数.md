显而易见，构造函数也是一个[[语法糖]]。
或者说：战吼。

#### 功能
构造函数的存在就是对类实例进行初始化操作的，即使你不写构造函数，实际上类本身默认就有一个构造函数，只是这个函数内部没有内容罢了。

在创造类实例的时候，构造函数会**自动运行**。
#### 限制
注意，构造函数只限==非static==。

构造函数可以[[重载]]，但是构造函数的命名必须==与类名一致==

#### 带参与非带参
##### 带参情况
假设我们有calss类为下例：

```
.....
class Entity
{
  public :
  int x,y;
  
  Entity(float x,float y)
  {
  X=x;
  Y=y;
  }
  void Print()
  {
  std::cout<<X<<","<<Y<<std::endl;
  }
......
};

......
int main()
{
Entity e(6.0,5.0);
e.Print();     //打印出来6.0,5.0;
}
```

我们发现初始化可以直接[[业主名]]然后括号，输入对应参数即可。

##### 非参情况
非参函数也是类似，只是如果你不写[[业主名]]之后的内容，那么初始化会根据非参构造函数内容而定。

#### 预防功能

假如我们想只用类，而不创实例。
==第一种方法==是：可以private一个空构造函数，例子如下：

```
class Log
{
private:
Log(){}

public:
static void Write(){}
};
......
int main()
{
Log::Write();
Log l;    //此行操作违法！会报错
}
```
原理就是，构造函数是在你==创造实例的时候自动运行的==。现在我们把构造函数private，也就是无法直接访问构造函数了。

如此创造Log类的实例就会违法报错，从而达到了避免创造实例的目的。



另外，上述例子还有==第二种预防方法==，就是直接写：
```
public:
Log() = delete;
```
通过删除构造函数的方式让类实例无法创造：因为创造实例时会自动运行构造函数，而构造函数被删除了，因此会报错。同样达到了禁止创造实例的目的
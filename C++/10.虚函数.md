#### 目的
虚函数的目的，如[[9.继承]]中所说的问题一样，我们来看以下代码：
```
class Entity 
{
public:
	std::string GetName() { return "Entity"; }
	

};
class Play : public Entity
{
private:
	std::string m_name;
public:
	Play(std::string name) 
		:m_name(name) {};
	std::string GetName()  { return m_name; }
	
};
void Print(Entity* e)
{
	std::cout<<e->GetName()<<std::endl;
}

int main()
{
	Entity* e = new Entity();
	Play* p = new Play("Cherno");
	Print(e);
	Print(p);
	
	std::cin.get();
}

```
结果如下，我们看到，即使我们创造了Play的实例，并初始化为Cherno，打印p的相应字符串，结果出来的是“Entity”。

![[P%O`V7U{$3)WA6UJN]A7_KJ.png]]

正如我们在[[9.继承]][9.继承](目的)








下面是有虚函数的类：
```
class Entity 
{
public:
	virtual std::string GetName() { return "Entity"; }
	

};
class Play : public Entity
{
private:
	std::string m_name;
public:
	Play(std::string name) 
		:m_name(name) {};
	std::string GetName() override { return m_name; }
};


int main()
{
	Entity* e = new Entity();
	Play*   p = new Play("Cherno");
	 std::cout<<e->GetName()<<std::endl;
	  std::cout<<p->GetName()<<std::endl;
	  std::cin.get();
}
```
回得到以下结果：
![[O[1M6V36HWPRT0L9_[TZA9R.png]]